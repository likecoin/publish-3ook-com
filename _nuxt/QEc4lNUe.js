import{bE as ce,bF as ae,bG as le,bH as ue}from"./9S2XGRg9.js";import{h as de}from"./BP1oHQun.js";(function(){try{var e=typeof window<"u"?window:typeof global<"u"?global:typeof globalThis<"u"?globalThis:typeof self<"u"?self:{};e.SENTRY_RELEASE={id:"cd189bad150b481aa5ecb2e95de26ec677010e55"}}catch{}})();try{(function(){var e=typeof window<"u"?window:typeof global<"u"?global:typeof globalThis<"u"?globalThis:typeof self<"u"?self:{},n=new e.Error().stack;n&&(e._sentryDebugIds=e._sentryDebugIds||{},e._sentryDebugIds[n]="4d99aae3-9421-4db9-97a7-85365cbdb6c0",e._sentryDebugIdIdentifier="sentry-dbid-4d99aae3-9421-4db9-97a7-85365cbdb6c0")})()}catch{}const Zt=BigInt(0),Nt=BigInt(1);function lt(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&e.constructor.name==="Uint8Array"}function zt(e){if(!lt(e))throw new Error("Uint8Array expected")}function ct(e,n){if(typeof n!="boolean")throw new Error(e+" boolean expected, got "+n)}function dt(e){const n=e.toString(16);return n.length&1?"0"+n:n}function Dt(e){if(typeof e!="string")throw new Error("hex string expected, got "+typeof e);return e===""?Zt:BigInt("0x"+e)}const $t=typeof Uint8Array.from([]).toHex=="function"&&typeof Uint8Array.fromHex=="function",he=Array.from({length:256},(e,n)=>n.toString(16).padStart(2,"0"));function at(e){if(zt(e),$t)return e.toHex();let n="";for(let t=0;t<e.length;t++)n+=he[e[t]];return n}const G={_0:48,_9:57,A:65,F:70,a:97,f:102};function kt(e){if(e>=G._0&&e<=G._9)return e-G._0;if(e>=G.A&&e<=G.F)return e-(G.A-10);if(e>=G.a&&e<=G.f)return e-(G.a-10)}function ht(e){if(typeof e!="string")throw new Error("hex string expected, got "+typeof e);if($t)return Uint8Array.fromHex(e);const n=e.length,t=n/2;if(n%2)throw new Error("hex string expected, got unpadded hex of length "+n);const r=new Uint8Array(t);for(let i=0,s=0;i<t;i++,s+=2){const a=kt(e.charCodeAt(s)),u=kt(e.charCodeAt(s+1));if(a===void 0||u===void 0){const o=e[s]+e[s+1];throw new Error('hex string expected, got non-hex character "'+o+'" at index '+s)}r[i]=a*16+u}return r}function et(e){return Dt(at(e))}function Gt(e){return zt(e),Dt(at(Uint8Array.from(e).reverse()))}function ut(e,n){return ht(e.toString(16).padStart(n*2,"0"))}function Wt(e,n){return ut(e,n).reverse()}function K(e,n,t){let r;if(typeof n=="string")try{r=ht(n)}catch(s){throw new Error(e+" must be hex string or Uint8Array, cause: "+s)}else if(lt(n))r=Uint8Array.from(n);else throw new Error(e+" must be hex string or Uint8Array");const i=r.length;if(typeof t=="number"&&i!==t)throw new Error(e+" of length "+t+" expected, got "+i);return r}function wt(...e){let n=0;for(let r=0;r<e.length;r++){const i=e[r];zt(i),n+=i.length}const t=new Uint8Array(n);for(let r=0,i=0;r<e.length;r++){const s=e[r];t.set(s,i),i+=s.length}return t}const bt=e=>typeof e=="bigint"&&Zt<=e;function Ut(e,n,t){return bt(e)&&bt(n)&&bt(t)&&n<=e&&e<t}function it(e,n,t,r){if(!Ut(n,t,r))throw new Error("expected valid "+e+": "+t+" <= n < "+r+", got "+n)}function we(e){let n;for(n=0;e>Zt;e>>=Nt,n+=1);return n}const gt=e=>(Nt<<BigInt(e))-Nt,Et=e=>new Uint8Array(e),Ct=e=>Uint8Array.from(e);function ge(e,n,t){if(typeof e!="number"||e<2)throw new Error("hashLen must be a number");if(typeof n!="number"||n<2)throw new Error("qByteLen must be a number");if(typeof t!="function")throw new Error("hmacFn must be a function");let r=Et(e),i=Et(e),s=0;const a=()=>{r.fill(1),i.fill(0),s=0},u=(...A)=>t(i,r,...A),o=(A=Et(0))=>{i=u(Ct([0]),A),r=u(),A.length!==0&&(i=u(Ct([1]),A),r=u())},d=()=>{if(s++>=1e3)throw new Error("drbg: tried 1000 values");let A=0;const N=[];for(;A<n;){r=u();const Z=r.slice();N.push(Z),A+=r.length}return wt(...N)};return(A,N)=>{a(),o(A);let Z;for(;!(Z=N(d()));)o();return a(),Z}}const me={bigint:e=>typeof e=="bigint",function:e=>typeof e=="function",boolean:e=>typeof e=="boolean",string:e=>typeof e=="string",stringOrUint8Array:e=>typeof e=="string"||lt(e),isSafeInteger:e=>Number.isSafeInteger(e),array:e=>Array.isArray(e),field:(e,n)=>n.Fp.isValid(e),hash:e=>typeof e=="function"&&Number.isSafeInteger(e.outputLen)};function mt(e,n,t={}){const r=(i,s,a)=>{const u=me[s];if(typeof u!="function")throw new Error("invalid validator function");const o=e[i];if(!(a&&o===void 0)&&!u(o,e))throw new Error("param "+String(i)+" is invalid. Expected "+s+", got "+o)};for(const[i,s]of Object.entries(n))r(i,s,!1);for(const[i,s]of Object.entries(t))r(i,s,!0);return e}function Ht(e){const n=new WeakMap;return(t,...r)=>{const i=n.get(t);if(i!==void 0)return i;const s=e(t,...r);return n.set(t,s),s}}const M=BigInt(0),H=BigInt(1),tt=BigInt(2),ye=BigInt(3),Xt=BigInt(4),Ft=BigInt(5),Qt=BigInt(8);function Y(e,n){const t=e%n;return t>=M?t:n+t}function j(e,n,t){let r=e;for(;n-- >M;)r*=r,r%=t;return r}function Ot(e,n){if(e===M)throw new Error("invert: expected non-zero number");if(n<=M)throw new Error("invert: expected positive modulus, got "+n);let t=Y(e,n),r=n,i=M,s=H;for(;t!==M;){const u=r/t,o=r%t,d=i-s*u;r=t,t=o,i=s,s=d}if(r!==H)throw new Error("invert: does not exist");return Y(i,n)}function Jt(e,n){const t=(e.ORDER+H)/Xt,r=e.pow(n,t);if(!e.eql(e.sqr(r),n))throw new Error("Cannot find square root");return r}function pe(e,n){const t=(e.ORDER-Ft)/Qt,r=e.mul(n,tt),i=e.pow(r,t),s=e.mul(n,i),a=e.mul(e.mul(s,tt),i),u=e.mul(s,e.sub(a,e.ONE));if(!e.eql(e.sqr(u),n))throw new Error("Cannot find square root");return u}function be(e){if(e<BigInt(3))throw new Error("sqrt is not defined for small field");let n=e-H,t=0;for(;n%tt===M;)n/=tt,t++;let r=tt;const i=_t(e);for(;Vt(i,r)===1;)if(r++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(t===1)return Jt;let s=i.pow(r,n);const a=(n+H)/tt;return function(o,d){if(o.is0(d))return d;if(Vt(o,d)!==1)throw new Error("Cannot find square root");let m=t,A=o.mul(o.ONE,s),N=o.pow(d,n),Z=o.pow(d,a);for(;!o.eql(N,o.ONE);){if(o.is0(N))return o.ZERO;let z=1,g=o.sqr(N);for(;!o.eql(g,o.ONE);)if(z++,g=o.sqr(g),z===m)throw new Error("Cannot find square root");const k=H<<BigInt(m-z-1),U=o.pow(A,k);m=z,A=o.sqr(U),N=o.mul(N,A),Z=o.mul(Z,U)}return Z}}function Ee(e){return e%Xt===ye?Jt:e%Qt===Ft?pe:be(e)}const Be=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function ve(e){const n={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},t=Be.reduce((r,i)=>(r[i]="function",r),n);return mt(e,t)}function xe(e,n,t){if(t<M)throw new Error("invalid exponent, negatives unsupported");if(t===M)return e.ONE;if(t===H)return n;let r=e.ONE,i=n;for(;t>M;)t&H&&(r=e.mul(r,i)),i=e.sqr(i),t>>=H;return r}function te(e,n,t=!1){const r=new Array(n.length).fill(t?e.ZERO:void 0),i=n.reduce((a,u,o)=>e.is0(u)?a:(r[o]=a,e.mul(a,u)),e.ONE),s=e.inv(i);return n.reduceRight((a,u,o)=>e.is0(u)?a:(r[o]=e.mul(a,r[o]),e.mul(a,u)),s),r}function Vt(e,n){const t=(e.ORDER-H)/tt,r=e.pow(n,t),i=e.eql(r,e.ONE),s=e.eql(r,e.ZERO),a=e.eql(r,e.neg(e.ONE));if(!i&&!s&&!a)throw new Error("invalid Legendre symbol result");return i?1:s?0:-1}function ee(e,n){n!==void 0&&ce(n);const t=n!==void 0?n:e.toString(2).length,r=Math.ceil(t/8);return{nBitLength:t,nByteLength:r}}function _t(e,n,t=!1,r={}){if(e<=M)throw new Error("invalid field: expected ORDER > 0, got "+e);const{nBitLength:i,nByteLength:s}=ee(e,n);if(s>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let a;const u=Object.freeze({ORDER:e,isLE:t,BITS:i,BYTES:s,MASK:gt(i),ZERO:M,ONE:H,create:o=>Y(o,e),isValid:o=>{if(typeof o!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof o);return M<=o&&o<e},is0:o=>o===M,isOdd:o=>(o&H)===H,neg:o=>Y(-o,e),eql:(o,d)=>o===d,sqr:o=>Y(o*o,e),add:(o,d)=>Y(o+d,e),sub:(o,d)=>Y(o-d,e),mul:(o,d)=>Y(o*d,e),pow:(o,d)=>xe(u,o,d),div:(o,d)=>Y(o*Ot(d,e),e),sqrN:o=>o*o,addN:(o,d)=>o+d,subN:(o,d)=>o-d,mulN:(o,d)=>o*d,inv:o=>Ot(o,e),sqrt:r.sqrt||(o=>(a||(a=Ee(e)),a(u,o))),toBytes:o=>t?Wt(o,s):ut(o,s),fromBytes:o=>{if(o.length!==s)throw new Error("Field.fromBytes: expected "+s+" bytes, got "+o.length);return t?Gt(o):et(o)},invertBatch:o=>te(u,o),cmov:(o,d,m)=>m?d:o});return Object.freeze(u)}function ne(e){if(typeof e!="bigint")throw new Error("field order must be bigint");const n=e.toString(2).length;return Math.ceil(n/8)}function re(e){const n=ne(e);return n+Math.ceil(n/2)}function Se(e,n,t=!1){const r=e.length,i=ne(n),s=re(n);if(r<16||r<s||r>1024)throw new Error("expected "+s+"-1024 bytes of input, got "+r);const a=t?Gt(e):et(e),u=Y(a,n-H)+H;return t?Wt(u,i):ut(u,i)}const Yt=BigInt(0),qt=BigInt(1);function Bt(e,n){const t=n.negate();return e?t:n}function oe(e,n){if(!Number.isSafeInteger(e)||e<=0||e>n)throw new Error("invalid window size, expected [1.."+n+"], got W="+e)}function vt(e,n){oe(e,n);const t=Math.ceil(n/e)+1,r=2**(e-1),i=2**e,s=gt(e),a=BigInt(e);return{windows:t,windowSize:r,mask:s,maxNumber:i,shiftBy:a}}function Mt(e,n,t){const{windowSize:r,mask:i,maxNumber:s,shiftBy:a}=t;let u=Number(e&i),o=e>>a;u>r&&(u-=s,o+=qt);const d=n*r,m=d+Math.abs(u)-1,A=u===0,N=u<0,Z=n%2!==0;return{nextN:o,offset:m,isZero:A,isNeg:N,isNegF:Z,offsetF:d}}function Ae(e,n){if(!Array.isArray(e))throw new Error("array expected");e.forEach((t,r)=>{if(!(t instanceof n))throw new Error("invalid point at index "+r)})}function Ie(e,n){if(!Array.isArray(e))throw new Error("array of scalars expected");e.forEach((t,r)=>{if(!n.isValid(t))throw new Error("invalid scalar at index "+r)})}const xt=new WeakMap,ie=new WeakMap;function St(e){return ie.get(e)||1}function Ne(e,n){return{constTimeNegate:Bt,hasPrecomputes(t){return St(t)!==1},unsafeLadder(t,r,i=e.ZERO){let s=t;for(;r>Yt;)r&qt&&(i=i.add(s)),s=s.double(),r>>=qt;return i},precomputeWindow(t,r){const{windows:i,windowSize:s}=vt(r,n),a=[];let u=t,o=u;for(let d=0;d<i;d++){o=u,a.push(o);for(let m=1;m<s;m++)o=o.add(u),a.push(o);u=o.double()}return a},wNAF(t,r,i){let s=e.ZERO,a=e.BASE;const u=vt(t,n);for(let o=0;o<u.windows;o++){const{nextN:d,offset:m,isZero:A,isNeg:N,isNegF:Z,offsetF:z}=Mt(i,o,u);i=d,A?a=a.add(Bt(Z,r[z])):s=s.add(Bt(N,r[m]))}return{p:s,f:a}},wNAFUnsafe(t,r,i,s=e.ZERO){const a=vt(t,n);for(let u=0;u<a.windows&&i!==Yt;u++){const{nextN:o,offset:d,isZero:m,isNeg:A}=Mt(i,u,a);if(i=o,!m){const N=r[d];s=s.add(A?N.negate():N)}}return s},getPrecomputes(t,r,i){let s=xt.get(r);return s||(s=this.precomputeWindow(r,t),t!==1&&xt.set(r,i(s))),s},wNAFCached(t,r,i){const s=St(t);return this.wNAF(s,this.getPrecomputes(s,t,i),r)},wNAFCachedUnsafe(t,r,i,s){const a=St(t);return a===1?this.unsafeLadder(t,r,s):this.wNAFUnsafe(a,this.getPrecomputes(a,t,i),r,s)},setWindowSize(t,r){oe(r,n),ie.set(t,r),xt.delete(t)}}}function Oe(e,n,t,r){Ae(t,e),Ie(r,n);const i=t.length,s=r.length;if(i!==s)throw new Error("arrays of points and scalars must have equal length");const a=e.ZERO,u=we(BigInt(i));let o=1;u>12?o=u-3:u>4?o=u-2:u>0&&(o=2);const d=gt(o),m=new Array(Number(d)+1).fill(a),A=Math.floor((n.BITS-1)/o)*o;let N=a;for(let Z=A;Z>=0;Z-=o){m.fill(a);for(let g=0;g<s;g++){const k=r[g],U=Number(k>>BigInt(Z)&d);m[U]=m[U].add(t[g])}let z=a;for(let g=m.length-1,k=a;g>0;g--)k=k.add(m[g]),z=z.add(k);if(N=N.add(z),Z!==0)for(let g=0;g<o;g++)N=N.double()}return N}function se(e){return ve(e.Fp),mt(e,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...ee(e.n,e.nBitLength),...e,p:e.Fp.ORDER})}function jt(e){e.lowS!==void 0&&ct("lowS",e.lowS),e.prehash!==void 0&&ct("prehash",e.prehash)}function qe(e){const n=se(e);mt(n,{a:"field",b:"field"},{allowInfinityPoint:"boolean",allowedPrivateKeyLengths:"array",clearCofactor:"function",fromBytes:"function",isTorsionFree:"function",toBytes:"function",wrapPrivateKey:"boolean"});const{endo:t,Fp:r,a:i}=n;if(t){if(!r.eql(i,r.ZERO))throw new Error("invalid endo: CURVE.a must be 0");if(typeof t!="object"||typeof t.beta!="bigint"||typeof t.splitScalar!="function")throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function')}return Object.freeze({...n})}class Re extends Error{constructor(n=""){super(n)}}const W={Err:Re,_tlv:{encode:(e,n)=>{const{Err:t}=W;if(e<0||e>256)throw new t("tlv.encode: wrong tag");if(n.length&1)throw new t("tlv.encode: unpadded data");const r=n.length/2,i=dt(r);if(i.length/2&128)throw new t("tlv.encode: long form length too big");const s=r>127?dt(i.length/2|128):"";return dt(e)+s+i+n},decode(e,n){const{Err:t}=W;let r=0;if(e<0||e>256)throw new t("tlv.encode: wrong tag");if(n.length<2||n[r++]!==e)throw new t("tlv.decode: wrong tlv");const i=n[r++],s=!!(i&128);let a=0;if(!s)a=i;else{const o=i&127;if(!o)throw new t("tlv.decode(long): indefinite length not supported");if(o>4)throw new t("tlv.decode(long): byte length is too big");const d=n.subarray(r,r+o);if(d.length!==o)throw new t("tlv.decode: length bytes not complete");if(d[0]===0)throw new t("tlv.decode(long): zero leftmost byte");for(const m of d)a=a<<8|m;if(r+=o,a<128)throw new t("tlv.decode(long): not minimal encoding")}const u=n.subarray(r,r+a);if(u.length!==a)throw new t("tlv.decode: wrong value length");return{v:u,l:n.subarray(r+a)}}},_int:{encode(e){const{Err:n}=W;if(e<X)throw new n("integer: negative integers are not allowed");let t=dt(e);if(Number.parseInt(t[0],16)&8&&(t="00"+t),t.length&1)throw new n("unexpected DER parsing assertion: unpadded hex");return t},decode(e){const{Err:n}=W;if(e[0]&128)throw new n("invalid signature integer: negative");if(e[0]===0&&!(e[1]&128))throw new n("invalid signature integer: unnecessary leading zero");return et(e)}},toSig(e){const{Err:n,_int:t,_tlv:r}=W,i=K("signature",e),{v:s,l:a}=r.decode(48,i);if(a.length)throw new n("invalid signature: left bytes after parsing");const{v:u,l:o}=r.decode(2,s),{v:d,l:m}=r.decode(2,o);if(m.length)throw new n("invalid signature: left bytes after parsing");return{r:t.decode(u),s:t.decode(d)}},hexFromSig(e){const{_tlv:n,_int:t}=W,r=n.encode(2,t.encode(e.r)),i=n.encode(2,t.encode(e.s)),s=r+i;return n.encode(48,s)}};function At(e,n){return at(ut(e,n))}const X=BigInt(0),_=BigInt(1);BigInt(2);const It=BigInt(3),Te=BigInt(4);function Ze(e){const n=qe(e),{Fp:t}=n,r=_t(n.n,n.nBitLength),i=n.toBytes||((x,f,h)=>{const y=f.toAffine();return wt(Uint8Array.from([4]),t.toBytes(y.x),t.toBytes(y.y))}),s=n.fromBytes||(x=>{const f=x.subarray(1),h=t.fromBytes(f.subarray(0,t.BYTES)),y=t.fromBytes(f.subarray(t.BYTES,2*t.BYTES));return{x:h,y}});function a(x){const{a:f,b:h}=n,y=t.sqr(x),B=t.mul(y,x);return t.add(t.add(B,t.mul(x,f)),h)}function u(x,f){const h=t.sqr(f),y=a(x);return t.eql(h,y)}if(!u(n.Gx,n.Gy))throw new Error("bad curve params: generator point");const o=t.mul(t.pow(n.a,It),Te),d=t.mul(t.sqr(n.b),BigInt(27));if(t.is0(t.add(o,d)))throw new Error("bad curve params: a or b");function m(x){return Ut(x,_,n.n)}function A(x){const{allowedPrivateKeyLengths:f,nByteLength:h,wrapPrivateKey:y,n:B}=n;if(f&&typeof x!="bigint"){if(lt(x)&&(x=at(x)),typeof x!="string"||!f.includes(x.length))throw new Error("invalid private key");x=x.padStart(h*2,"0")}let O;try{O=typeof x=="bigint"?x:et(K("private key",x,h))}catch{throw new Error("invalid private key, expected hex or "+h+" bytes, got "+typeof x)}return y&&(O=Y(O,B)),it("private key",O,_,B),O}function N(x){if(!(x instanceof g))throw new Error("ProjectivePoint expected")}const Z=Ht((x,f)=>{const{px:h,py:y,pz:B}=x;if(t.eql(B,t.ONE))return{x:h,y};const O=x.is0();f==null&&(f=O?t.ONE:t.inv(B));const R=t.mul(h,f),q=t.mul(y,f),p=t.mul(B,f);if(O)return{x:t.ZERO,y:t.ZERO};if(!t.eql(p,t.ONE))throw new Error("invZ was invalid");return{x:R,y:q}}),z=Ht(x=>{if(x.is0()){if(n.allowInfinityPoint&&!t.is0(x.py))return;throw new Error("bad point: ZERO")}const{x:f,y:h}=x.toAffine();if(!t.isValid(f)||!t.isValid(h))throw new Error("bad point: x or y not FE");if(!u(f,h))throw new Error("bad point: equation left != right");if(!x.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class g{constructor(f,h,y){if(f==null||!t.isValid(f))throw new Error("x required");if(h==null||!t.isValid(h)||t.is0(h))throw new Error("y required");if(y==null||!t.isValid(y))throw new Error("z required");this.px=f,this.py=h,this.pz=y,Object.freeze(this)}static fromAffine(f){const{x:h,y}=f||{};if(!f||!t.isValid(h)||!t.isValid(y))throw new Error("invalid affine point");if(f instanceof g)throw new Error("projective point not allowed");const B=O=>t.eql(O,t.ZERO);return B(h)&&B(y)?g.ZERO:new g(h,y,t.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(f){const h=te(t,f.map(y=>y.pz));return f.map((y,B)=>y.toAffine(h[B])).map(g.fromAffine)}static fromHex(f){const h=g.fromAffine(s(K("pointHex",f)));return h.assertValidity(),h}static fromPrivateKey(f){return g.BASE.multiply(A(f))}static msm(f,h){return Oe(g,r,f,h)}_setWindowSize(f){D.setWindowSize(this,f)}assertValidity(){z(this)}hasEvenY(){const{y:f}=this.toAffine();if(t.isOdd)return!t.isOdd(f);throw new Error("Field doesn't support isOdd")}equals(f){N(f);const{px:h,py:y,pz:B}=this,{px:O,py:R,pz:q}=f,p=t.eql(t.mul(h,q),t.mul(O,B)),I=t.eql(t.mul(y,q),t.mul(R,B));return p&&I}negate(){return new g(this.px,t.neg(this.py),this.pz)}double(){const{a:f,b:h}=n,y=t.mul(h,It),{px:B,py:O,pz:R}=this;let q=t.ZERO,p=t.ZERO,I=t.ZERO,b=t.mul(B,B),L=t.mul(O,O),l=t.mul(R,R),c=t.mul(B,O);return c=t.add(c,c),I=t.mul(B,R),I=t.add(I,I),q=t.mul(f,I),p=t.mul(y,l),p=t.add(q,p),q=t.sub(L,p),p=t.add(L,p),p=t.mul(q,p),q=t.mul(c,q),I=t.mul(y,I),l=t.mul(f,l),c=t.sub(b,l),c=t.mul(f,c),c=t.add(c,I),I=t.add(b,b),b=t.add(I,b),b=t.add(b,l),b=t.mul(b,c),p=t.add(p,b),l=t.mul(O,R),l=t.add(l,l),b=t.mul(l,c),q=t.sub(q,b),I=t.mul(l,L),I=t.add(I,I),I=t.add(I,I),new g(q,p,I)}add(f){N(f);const{px:h,py:y,pz:B}=this,{px:O,py:R,pz:q}=f;let p=t.ZERO,I=t.ZERO,b=t.ZERO;const L=n.a,l=t.mul(n.b,It);let c=t.mul(h,O),w=t.mul(y,R),S=t.mul(B,q),E=t.add(h,y),v=t.add(O,R);E=t.mul(E,v),v=t.add(c,w),E=t.sub(E,v),v=t.add(h,B);let T=t.add(O,q);return v=t.mul(v,T),T=t.add(c,S),v=t.sub(v,T),T=t.add(y,B),p=t.add(R,q),T=t.mul(T,p),p=t.add(w,S),T=t.sub(T,p),b=t.mul(L,v),p=t.mul(l,S),b=t.add(p,b),p=t.sub(w,b),b=t.add(w,b),I=t.mul(p,b),w=t.add(c,c),w=t.add(w,c),S=t.mul(L,S),v=t.mul(l,v),w=t.add(w,S),S=t.sub(c,S),S=t.mul(L,S),v=t.add(v,S),c=t.mul(w,v),I=t.add(I,c),c=t.mul(T,v),p=t.mul(E,p),p=t.sub(p,c),c=t.mul(E,w),b=t.mul(T,b),b=t.add(b,c),new g(p,I,b)}subtract(f){return this.add(f.negate())}is0(){return this.equals(g.ZERO)}wNAF(f){return D.wNAFCached(this,f,g.normalizeZ)}multiplyUnsafe(f){const{endo:h,n:y}=n;it("scalar",f,X,y);const B=g.ZERO;if(f===X)return B;if(this.is0()||f===_)return this;if(!h||D.hasPrecomputes(this))return D.wNAFCachedUnsafe(this,f,g.normalizeZ);let{k1neg:O,k1:R,k2neg:q,k2:p}=h.splitScalar(f),I=B,b=B,L=this;for(;R>X||p>X;)R&_&&(I=I.add(L)),p&_&&(b=b.add(L)),L=L.double(),R>>=_,p>>=_;return O&&(I=I.negate()),q&&(b=b.negate()),b=new g(t.mul(b.px,h.beta),b.py,b.pz),I.add(b)}multiply(f){const{endo:h,n:y}=n;it("scalar",f,_,y);let B,O;if(h){const{k1neg:R,k1:q,k2neg:p,k2:I}=h.splitScalar(f);let{p:b,f:L}=this.wNAF(q),{p:l,f:c}=this.wNAF(I);b=D.constTimeNegate(R,b),l=D.constTimeNegate(p,l),l=new g(t.mul(l.px,h.beta),l.py,l.pz),B=b.add(l),O=L.add(c)}else{const{p:R,f:q}=this.wNAF(f);B=R,O=q}return g.normalizeZ([B,O])[0]}multiplyAndAddUnsafe(f,h,y){const B=g.BASE,O=(q,p)=>p===X||p===_||!q.equals(B)?q.multiplyUnsafe(p):q.multiply(p),R=O(this,h).add(O(f,y));return R.is0()?void 0:R}toAffine(f){return Z(this,f)}isTorsionFree(){const{h:f,isTorsionFree:h}=n;if(f===_)return!0;if(h)return h(g,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:f,clearCofactor:h}=n;return f===_?this:h?h(g,this):this.multiplyUnsafe(n.h)}toRawBytes(f=!0){return ct("isCompressed",f),this.assertValidity(),i(g,this,f)}toHex(f=!0){return ct("isCompressed",f),at(this.toRawBytes(f))}}g.BASE=new g(n.Gx,n.Gy,t.ONE),g.ZERO=new g(t.ZERO,t.ONE,t.ZERO);const{endo:k,nBitLength:U}=n,D=Ne(g,k?Math.ceil(U/2):U);return{CURVE:n,ProjectivePoint:g,normPrivateKeyToScalar:A,weierstrassEquation:a,isWithinCurveOrder:m}}function ze(e){const n=se(e);return mt(n,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...n})}function Ue(e){const n=ze(e),{Fp:t,n:r,nByteLength:i,nBitLength:s}=n,a=t.BYTES+1,u=2*t.BYTES+1;function o(l){return Y(l,r)}function d(l){return Ot(l,r)}const{ProjectivePoint:m,normPrivateKeyToScalar:A,weierstrassEquation:N,isWithinCurveOrder:Z}=Ze({...n,toBytes(l,c,w){const S=c.toAffine(),E=t.toBytes(S.x),v=wt;return ct("isCompressed",w),w?v(Uint8Array.from([c.hasEvenY()?2:3]),E):v(Uint8Array.from([4]),E,t.toBytes(S.y))},fromBytes(l){const c=l.length,w=l[0],S=l.subarray(1);if(c===a&&(w===2||w===3)){const E=et(S);if(!Ut(E,_,t.ORDER))throw new Error("Point is not on curve");const v=N(E);let T;try{T=t.sqrt(v)}catch(P){const V=P instanceof Error?": "+P.message:"";throw new Error("Point is not on curve"+V)}const C=(T&_)===_;return(w&1)===1!==C&&(T=t.neg(T)),{x:E,y:T}}else if(c===u&&w===4){const E=t.fromBytes(S.subarray(0,t.BYTES)),v=t.fromBytes(S.subarray(t.BYTES,2*t.BYTES));return{x:E,y:v}}else{const E=a,v=u;throw new Error("invalid Point, expected length of "+E+", or uncompressed "+v+", got "+c)}}});function z(l){const c=r>>_;return l>c}function g(l){return z(l)?o(-l):l}const k=(l,c,w)=>et(l.slice(c,w));class U{constructor(c,w,S){it("r",c,_,r),it("s",w,_,r),this.r=c,this.s=w,S!=null&&(this.recovery=S),Object.freeze(this)}static fromCompact(c){const w=i;return c=K("compactSignature",c,w*2),new U(k(c,0,w),k(c,w,2*w))}static fromDER(c){const{r:w,s:S}=W.toSig(K("DER",c));return new U(w,S)}assertValidity(){}addRecoveryBit(c){return new U(this.r,this.s,c)}recoverPublicKey(c){const{r:w,s:S,recovery:E}=this,v=B(K("msgHash",c));if(E==null||![0,1,2,3].includes(E))throw new Error("recovery id invalid");const T=E===2||E===3?w+n.n:w;if(T>=t.ORDER)throw new Error("recovery id 2 or 3 invalid");const C=(E&1)===0?"02":"03",$=m.fromHex(C+At(T,t.BYTES)),P=d(T),V=o(-v*P),nt=o(S*P),F=m.BASE.multiplyAndAddUnsafe($,V,nt);if(!F)throw new Error("point at infinify");return F.assertValidity(),F}hasHighS(){return z(this.s)}normalizeS(){return this.hasHighS()?new U(this.r,o(-this.s),this.recovery):this}toDERRawBytes(){return ht(this.toDERHex())}toDERHex(){return W.hexFromSig(this)}toCompactRawBytes(){return ht(this.toCompactHex())}toCompactHex(){const c=i;return At(this.r,c)+At(this.s,c)}}const D={isValidPrivateKey(l){try{return A(l),!0}catch{return!1}},normPrivateKeyToScalar:A,randomPrivateKey:()=>{const l=re(n.n);return Se(n.randomBytes(l),n.n)},precompute(l=8,c=m.BASE){return c._setWindowSize(l),c.multiply(BigInt(3)),c}};function x(l,c=!0){return m.fromPrivateKey(l).toRawBytes(c)}function f(l){if(typeof l=="bigint")return!1;if(l instanceof m)return!0;const w=K("key",l).length,S=t.BYTES,E=S+1,v=2*S+1;if(!(n.allowedPrivateKeyLengths||i===E))return w===E||w===v}function h(l,c,w=!0){if(f(l)===!0)throw new Error("first arg must be private key");if(f(c)===!1)throw new Error("second arg must be public key");return m.fromHex(c).multiply(A(l)).toRawBytes(w)}const y=n.bits2int||function(l){if(l.length>8192)throw new Error("input is too large");const c=et(l),w=l.length*8-s;return w>0?c>>BigInt(w):c},B=n.bits2int_modN||function(l){return o(y(l))},O=gt(s);function R(l){return it("num < 2^"+s,l,X,O),ut(l,i)}function q(l,c,w=p){if(["recovered","canonical"].some(Q=>Q in w))throw new Error("sign() legacy options not supported");const{hash:S,randomBytes:E}=n;let{lowS:v,prehash:T,extraEntropy:C}=w;v==null&&(v=!0),l=K("msgHash",l),jt(w),T&&(l=K("prehashed msgHash",S(l)));const $=B(l),P=A(c),V=[R(P),R($)];if(C!=null&&C!==!1){const Q=C===!0?E(t.BYTES):C;V.push(K("extraEntropy",Q))}const nt=wt(...V),F=$;function yt(Q){const rt=y(Q);if(!Z(rt))return;const pt=d(rt),st=m.BASE.multiply(rt).toAffine(),J=o(st.x);if(J===X)return;const ft=o(pt*o(F+J*P));if(ft===X)return;let ot=(st.x===J?0:2)|Number(st.y&_),Lt=ft;return v&&z(ft)&&(Lt=g(ft),ot^=1),new U(J,Lt,ot)}return{seed:nt,k2sig:yt}}const p={lowS:n.lowS,prehash:!1},I={lowS:n.lowS,prehash:!1};function b(l,c,w=p){const{seed:S,k2sig:E}=q(l,c,w),v=n;return ge(v.hash.outputLen,v.nByteLength,v.hmac)(S,E)}m.BASE._setWindowSize(8);function L(l,c,w,S=I){const E=l;c=K("msgHash",c),w=K("publicKey",w);const{lowS:v,prehash:T,format:C}=S;if(jt(S),"strict"in S)throw new Error("options.strict was renamed to lowS");if(C!==void 0&&C!=="compact"&&C!=="der")throw new Error("format must be compact or der");const $=typeof E=="string"||lt(E),P=!$&&!C&&typeof E=="object"&&E!==null&&typeof E.r=="bigint"&&typeof E.s=="bigint";if(!$&&!P)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let V,nt;try{if(P&&(V=new U(E.r,E.s)),$){try{C!=="compact"&&(V=U.fromDER(E))}catch(ot){if(!(ot instanceof W.Err))throw ot}!V&&C!=="der"&&(V=U.fromCompact(E))}nt=m.fromHex(w)}catch{return!1}if(!V||v&&V.hasHighS())return!1;T&&(c=n.hash(c));const{r:F,s:yt}=V,Q=B(c),rt=d(yt),pt=o(Q*rt),st=o(F*rt),J=m.BASE.multiplyAndAddUnsafe(nt,pt,st)?.toAffine();return J?o(J.x)===F:!1}return{CURVE:n,getPublicKey:x,getSharedSecret:h,sign:b,verify:L,ProjectivePoint:m,Signature:U,utils:D}}function _e(e){return{hash:e,hmac:(n,...t)=>de(e,n,le(...t)),randomBytes:ae}}function Le(e,n){const t=r=>Ue({...e,..._e(r)});return{...t(n),create:t}}const fe=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),Kt=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),ke=BigInt(0),Ce=BigInt(1),Rt=BigInt(2),Pt=(e,n)=>(e+n/Rt)/n;function He(e){const n=fe,t=BigInt(3),r=BigInt(6),i=BigInt(11),s=BigInt(22),a=BigInt(23),u=BigInt(44),o=BigInt(88),d=e*e*e%n,m=d*d*e%n,A=j(m,t,n)*m%n,N=j(A,t,n)*m%n,Z=j(N,Rt,n)*d%n,z=j(Z,i,n)*Z%n,g=j(z,s,n)*z%n,k=j(g,u,n)*g%n,U=j(k,o,n)*k%n,D=j(U,u,n)*g%n,x=j(D,t,n)*m%n,f=j(x,a,n)*z%n,h=j(f,r,n)*d%n,y=j(h,Rt,n);if(!Tt.eql(Tt.sqr(y),e))throw new Error("Cannot find square root");return y}const Tt=_t(fe,void 0,void 0,{sqrt:He}),Me=Le({a:ke,b:BigInt(7),Fp:Tt,n:Kt,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:e=>{const n=Kt,t=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-Ce*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),i=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),s=t,a=BigInt("0x100000000000000000000000000000000"),u=Pt(s*e,n),o=Pt(-r*e,n);let d=Y(e-u*t-o*i,n),m=Y(-u*r-o*s,n);const A=d>a,N=m>a;if(A&&(d=n-d),N&&(m=n-m),d>a||m>a)throw new Error("splitScalar: Endomorphism failed, k="+e);return{k1neg:A,k1:d,k2neg:N,k2:m}}}},ue);export{Me as secp256k1};
