import{b as h,c as P}from"./CSf5BCM0.js";import{bI as g,bJ as L,bK as O,bL as T,bM as D,bN as x,bO as E,bP as $,bQ as y,bR as q,bS as R,bT as _,bU as G,bV as v,bW as m,bX as F,bY as M,bZ as C,b_ as H,b$ as U,c0 as A,c1 as j}from"./9S2XGRg9.js";(function(){try{var t=typeof window<"u"?window:typeof global<"u"?global:typeof globalThis<"u"?globalThis:typeof self<"u"?self:{};t.SENTRY_RELEASE={id:"cd189bad150b481aa5ecb2e95de26ec677010e55"}}catch{}})();try{(function(){var t=typeof window<"u"?window:typeof global<"u"?global:typeof globalThis<"u"?globalThis:typeof self<"u"?self:{},n=new t.Error().stack;n&&(t._sentryDebugIds=t._sentryDebugIds||{},t._sentryDebugIds[n]="00850cff-9a19-4aa7-a513-fb8fb2b8fffe",t._sentryDebugIdIdentifier="sentry-dbid-00850cff-9a19-4aa7-a513-fb8fb2b8fffe")})()}catch{}function B(t){const{abi:n,data:a}=t,s=g(a,0,4),e=n.find(r=>r.type==="function"&&s===L(O(r)));if(!e)throw new T(s,{docsPath:"/docs/contract/decodeFunctionData"});return{functionName:e.name,args:"inputs"in e&&e.inputs&&e.inputs.length>0?D(e.inputs,g(a,4)):void 0}}const b="/docs/contract/encodeErrorResult";function k(t){const{abi:n,errorName:a,args:s}=t;let e=n[0];if(a){const d=x({abi:n,args:s,name:a});if(!d)throw new E(a,{docsPath:b});e=d}if(e.type!=="error")throw new E(void 0,{docsPath:b});const r=O(e),o=L(r);let c="0x";if(s&&s.length>0){if(!e.inputs)throw new $(e.name,{docsPath:b});c=y(e.inputs,s)}return q([o,c])}const p="/docs/contract/encodeFunctionResult";function J(t){const{abi:n,functionName:a,result:s}=t;let e=n[0];if(a){const o=x({abi:n,name:a});if(!o)throw new R(a,{docsPath:p});e=o}if(e.type!=="function")throw new R(void 0,{docsPath:p});if(!e.outputs)throw new _(e.name,{docsPath:p});const r=(()=>{if(e.outputs.length===0)return[];if(e.outputs.length===1)return[s];if(Array.isArray(s))return s;throw new G(s)})();return y(e.outputs,r)}const N="x-batch-gateway:true";async function S(t){const{data:n,ccipRequest:a}=t,{args:[s]}=B({abi:h,data:n}),e=[],r=[];return await Promise.all(s.map(async(o,c)=>{try{r[c]=o.urls.includes(N)?await S({data:o.data,ccipRequest:a}):await a(o),e[c]=!1}catch(d){e[c]=!0,r[c]=W(d)}})),J({abi:h,functionName:"query",result:[e,r]})}function W(t){return t.name==="HttpRequestError"&&t.status?k({abi:h,errorName:"HttpError",args:[t.status,t.shortMessage]}):k({abi:[v],errorName:"Error",args:["shortMessage"in t?t.shortMessage:t.message]})}class Y extends m{constructor({callbackSelector:n,cause:a,data:s,extraData:e,sender:r,urls:o}){super(a.shortMessage||"An error occurred while fetching for an offchain result.",{cause:a,metaMessages:[...a.metaMessages||[],a.metaMessages?.length?"":[],"Offchain Gateway Call:",o&&["  Gateway URL(s):",...o.map(c=>`    ${F(c)}`)],`  Sender: ${r}`,`  Data: ${s}`,`  Callback selector: ${n}`,`  Extra data: ${e}`].flat(),name:"OffchainLookupError"})}}class K extends m{constructor({result:n,url:a}){super("Offchain gateway response is malformed. Response data must be a hex value.",{metaMessages:[`Gateway URL: ${F(a)}`,`Response: ${M(n)}`],name:"OffchainLookupResponseMalformedError"})}}class Q extends m{constructor({sender:n,to:a}){super("Reverted sender address does not match target contract address (`to`).",{metaMessages:[`Contract address: ${a}`,`OffchainLookup sender address: ${n}`],name:"OffchainLookupSenderMismatchError"})}}const ee="0x556f1830",V={name:"OffchainLookup",type:"error",inputs:[{name:"sender",type:"address"},{name:"urls",type:"string[]"},{name:"callData",type:"bytes"},{name:"callbackFunction",type:"bytes4"},{name:"extraData",type:"bytes"}]};async function te(t,{blockNumber:n,blockTag:a,data:s,to:e}){const{args:r}=C({data:s,abi:[V]}),[o,c,d,i,u]=r,{ccipRead:f}=t,w=f&&typeof f?.request=="function"?f.request:X;try{if(!H(e,o))throw new Q({sender:o,to:e});const l=c.includes(N)?await S({data:d,ccipRequest:w}):await w({data:d,sender:o,urls:c}),{data:I}=await P(t,{blockNumber:n,blockTag:a,data:U([i,y([{type:"bytes"},{type:"bytes"}],[l,u])]),to:e});return I}catch(l){throw new Y({callbackSelector:i,cause:l,data:s,extraData:u,sender:o,urls:c})}}async function X({data:t,sender:n,urls:a}){let s=new Error("An unknown error occurred.");for(let e=0;e<a.length;e++){const r=a[e],o=r.includes("{data}")?"GET":"POST",c=o==="POST"?{data:t,sender:n}:void 0,d=o==="POST"?{"Content-Type":"application/json"}:{};try{const i=await fetch(r.replace("{sender}",n.toLowerCase()).replace("{data}",t),{body:JSON.stringify(c),headers:d,method:o});let u;if(i.headers.get("Content-Type")?.startsWith("application/json")?u=(await i.json()).data:u=await i.text(),!i.ok){s=new A({body:c,details:u?.error?M(u.error):i.statusText,headers:i.headers,status:i.status,url:r});continue}if(!j(u)){s=new K({result:u,url:r});continue}return u}catch(i){s=new A({body:c,details:i.message,url:r})}}throw s}export{X as ccipRequest,te as offchainLookup,V as offchainLookupAbiItem,ee as offchainLookupSignature};
